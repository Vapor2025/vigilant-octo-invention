<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>新春纸雕艺术 - 竖版长图</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html {
            overflow-x: hidden;
            overflow-y: auto;
            height: 100%;
        }
        body {
            margin: 0;
            padding: 0;
            background: #c8102e;
            font-family: 'KaiTi', 'STKaiti', '楷体', serif;
            min-height: 100%;
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        #canvas-container {
            width: 100vw;
            height: 400vh;
            position: relative;
            overflow: visible;
            touch-action: pan-y;
        }
        .loading {
            display: none;
        }
        .scroll-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 14px;
            z-index: 100;
            opacity: 0.7;
            animation: bounce 2s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }
        .section-title {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: #fff8dc;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            z-index: 50;
            opacity: 0;
            transition: opacity 1s ease;
        }
        .feedback-link {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 248, 220, 0.6);
            font-size: 12px;
            z-index: 100;
            text-decoration: none;
            transition: all 0.3s ease;
            cursor: pointer;
            opacity: 0;
        }
        .feedback-link.visible {
            opacity: 1;
        }
        .feedback-link:hover {
            color: rgba(255, 248, 220, 0.9);
            text-shadow: 0 0 8px rgba(255, 248, 220, 0.5);
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="loading" id="loading">新春纸雕艺术加载中...</div>
        <div class="scroll-indicator" id="indicator">↓ 向下滑动欣赏 ↓</div>
        <div class="section-title" id="title1" style="top: 15%;">新春</div>
        <div class="section-title" id="title2" style="top: 35%;">纸雕</div>
        <div class="section-title" id="title3" style="top: 55%;">艺术</div>
        <div class="section-title" id="title4" style="top: 75%;">2026</div>
        <a href="https://wj.qq.com/s2/25722416/b2e6/" target="_blank" class="feedback-link" id="feedback">问题反馈</a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 竖向滚动长图场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xc8102e);
        
        // 竖版相机设置（更窄的视角，适合长图）
        const camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 25);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.domElement.style.position = 'fixed';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.left = '0';
        renderer.domElement.style.pointerEvents = 'none';
        renderer.domElement.style.zIndex = '1';
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // 灯光设置
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
        mainLight.position.set(0, 20, 15);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 100;
        mainLight.shadow.camera.left = -25;
        mainLight.shadow.camera.right = 25;
        mainLight.shadow.camera.top = 50;
        mainLight.shadow.camera.bottom = -50;
        scene.add(mainLight);
        
        // 纸张材质
        const createPaperMaterial = (color, side = THREE.DoubleSide) => {
            return new THREE.MeshLambertMaterial({
                color: color,
                side: side,
                transparent: true,
                opacity: 0.95
            });
        };
        
        const redPaperMaterial = createPaperMaterial(0xdc143c);
        const whitePaperMaterial = createPaperMaterial(0xfff8dc);
        const lightRedMaterial = createPaperMaterial(0xff6b6b);
        const goldMaterial = createPaperMaterial(0xffd700);
        
        // 创建竖向拱门
        const createVerticalArch = (yPos) => {
            const archGroup = new THREE.Group();
            
            // 竖向门框
            const frameGeometry = new THREE.BoxGeometry(7, 9, 0.3);
            const frame = new THREE.Mesh(frameGeometry, redPaperMaterial);
            frame.castShadow = true;
            frame.receiveShadow = true;
            archGroup.add(frame);
            
            // 拱形门洞
            const archShape = new THREE.Shape();
            archShape.moveTo(-2.5, -2.8);
            archShape.lineTo(-2.5, 2.5);
            archShape.absarc(0, 2.5, 2.5, Math.PI, 0, false);
            archShape.lineTo(2.5, -2.8);
            archShape.lineTo(-2.5, -2.8);
            
            const archHole = new THREE.Path();
            archHole.moveTo(-2, -2.3);
            archHole.lineTo(-2, 2);
            archHole.absarc(0, 2, 2, Math.PI, 0, false);
            archHole.lineTo(2, -2.3);
            archHole.lineTo(-2, -2.3);
            archShape.holes.push(archHole);
            
            const archGeometry = new THREE.ExtrudeGeometry(archShape, {
                depth: 0.3,
                bevelEnabled: true,
                bevelThickness: 0.05,
                bevelSize: 0.05
            });
            const archFrame = new THREE.Mesh(archGeometry, redPaperMaterial);
            archFrame.position.z = 0.15;
            archGroup.add(archFrame);
            
            // 卷草纹装饰
            for (let i = 0; i < 8; i++) {
                const vineGeometry = new THREE.TorusGeometry(0.25 + Math.random() * 0.15, 0.04, 6, 12);
                const vine = new THREE.Mesh(vineGeometry, lightRedMaterial);
                const angle = (i / 8) * Math.PI * 2;
                vine.position.set(
                    Math.cos(angle) * 3.2,
                    Math.sin(angle) * 3.2 + 2.5,
                    0.4
                );
                vine.rotation.z = angle;
                archGroup.add(vine);
            }
            
            archGroup.position.y = yPos;
            return archGroup;
        };
        
        // 创建竖版文字
        const createVerticalText = (text, yPos) => {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 512;
            
            context.fillStyle = '#dc143c';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'bold 160px KaiTi, STKaiti, serif';
            context.fillStyle = '#fff8dc';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // 竖排文字
            const chars = text.split('');
            chars.forEach((char, i) => {
                context.fillText(char, canvas.width / 2, canvas.height * (0.25 + i * 0.25));
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            const textGeometry = new THREE.PlaneGeometry(3, 6);
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.y = yPos;
            textMesh.position.z = 0.5;
            
            return textMesh;
        };
        
        // 创建亭台楼阁
        const createPavilion = (scale = 1) => {
            const pavilionGroup = new THREE.Group();
            
            // 基座
            const baseGeometry = new THREE.BoxGeometry(2 * scale, 0.3 * scale, 2 * scale);
            const base = new THREE.Mesh(baseGeometry, whitePaperMaterial);
            base.position.y = 0.15 * scale;
            pavilionGroup.add(base);
            
            // 主体
            const bodyGeometry = new THREE.BoxGeometry(1.5 * scale, 2 * scale, 1.5 * scale);
            const body = new THREE.Mesh(bodyGeometry, whitePaperMaterial);
            body.position.y = 1.3 * scale;
            pavilionGroup.add(body);
            
            // 飞檐
            for (let i = 0; i < 4; i++) {
                const eaveGeometry = new THREE.ConeGeometry(0.8 * scale, 0.5 * scale, 4);
                const eave = new THREE.Mesh(eaveGeometry, whitePaperMaterial);
                const angle = (i / 4) * Math.PI * 2;
                eave.position.set(
                    Math.cos(angle) * 0.5 * scale,
                    2.8 * scale,
                    Math.sin(angle) * 0.5 * scale
                );
                eave.rotation.y = angle;
                eave.castShadow = true;
                pavilionGroup.add(eave);
            }
            
            // 屋顶
            const roofGeometry = new THREE.ConeGeometry(1.2 * scale, 1 * scale, 4);
            const roof = new THREE.Mesh(roofGeometry, redPaperMaterial);
            roof.position.y = 3.5 * scale;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            pavilionGroup.add(roof);
            
            return pavilionGroup;
        };
        
        // 创建装饰图案
        const createDecoration = (yPos, type) => {
            const decorGroup = new THREE.Group();
            
            if (type === 'cloud') {
                // 云纹装饰
                for (let i = 0; i < 6; i++) {
                    const cloudGeometry = new THREE.SphereGeometry(0.6, 8, 6);
                    const cloud = new THREE.Mesh(cloudGeometry, lightRedMaterial);
                    cloud.position.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 3,
                        Math.random() * 3 - 1
                    );
                    cloud.scale.set(1.2, 0.6, 0.9);
                    cloud.material.transparent = true;
                    cloud.material.opacity = 0.6;
                    decorGroup.add(cloud);
                }
            } else if (type === 'flower') {
                // 花纹装饰
                for (let i = 0; i < 8; i++) {
                    const flowerGeometry = new THREE.SphereGeometry(0.3, 6, 4);
                    const flower = new THREE.Mesh(flowerGeometry, goldMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    flower.position.set(
                        Math.cos(angle) * 2.5,
                        Math.sin(angle) * 0.8,
                        0.5
                    );
                    decorGroup.add(flower);
                }
            }
            
            decorGroup.position.y = yPos;
            return decorGroup;
        };
        
        // 创建地面
        const createGround = () => {
            const groundGeometry = new THREE.PlaneGeometry(50, 300);  // 扩大地面
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xfff8dc,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -25;  // 向下移动地面
            ground.receiveShadow = true;
            return ground;
        };
        
        // 创建梅花枝装饰
        const createPlumDecoration = (side, yPos) => {
            const branchGroup = new THREE.Group();
            
            const mainBranchGeometry = new THREE.CylinderGeometry(0.08, 0.12, 6);
            const mainBranch = new THREE.Mesh(mainBranchGeometry, redPaperMaterial);
            mainBranch.rotation.z = side === 'left' ? 0.4 : -0.4;
            mainBranch.rotation.x = 0.2;
            branchGroup.add(mainBranch);
            
            for (let i = 0; i < 15; i++) {
                const subBranchGeometry = new THREE.CylinderGeometry(0.03, 0.04, 1);
                const subBranch = new THREE.Mesh(subBranchGeometry, redPaperMaterial);
                
                const t = i / 14;
                subBranch.position.set(
                    side === 'left' ? -1.5 + t * 3 : 1.5 - t * 3,
                    -2 + t * 4,
                    0
                );
                subBranch.rotation.z = (Math.random() - 0.5) * 0.8;
                subBranch.rotation.x = (Math.random() - 0.5) * 0.4;
                branchGroup.add(subBranch);
                
                const flowerGeometry = new THREE.SphereGeometry(0.15, 6, 4);
                const flower = new THREE.Mesh(flowerGeometry, lightRedMaterial);
                flower.position.copy(subBranch.position);
                flower.position.y += 0.5;
                flower.position.x += (Math.random() - 0.5) * 0.4;
                flower.material.transparent = true;
                flower.material.opacity = 0.7;
                branchGroup.add(flower);
            }
            
            branchGroup.position.set(side === 'left' ? -8 : 8, yPos, 5);
            return branchGroup;
        };
        
        // 创建长图场景（按垂直位置排列）- 整体下移确保新春显示完整
        const sceneElements = [];
        
        // 第一部分：顶部 - 下移让新春完整显示在顶部
        const topArch = createVerticalArch(8);  // 从18改为8
        scene.add(topArch);
        sceneElements.push(topArch);
        
        const topText = createVerticalText('新春', 12);  // 从22改为12
        scene.add(topText);
        sceneElements.push(topText);
        
        // 第二部分：上部
        const decor1 = createDecoration(2, 'cloud');  // 从12改为2
        scene.add(decor1);
        sceneElements.push(decor1);
        
        const pavilion1 = createPavilion(1.3);
        pavilion1.position.set(-3, 0, -4);  // 从10改为0
        pavilion1.userData = { baseScale: 1.3 };
        scene.add(pavilion1);
        sceneElements.push(pavilion1);
        
        const pavilion2 = createPavilion(0.9);
        pavilion2.position.set(3, -2, -5);  // 从8改为-2
        pavilion2.userData = { baseScale: 0.9 };
        scene.add(pavilion2);
        sceneElements.push(pavilion2);
        
        // 第三部分：中部
        const midArch = createVerticalArch(-7);  // 从3改为-7
        scene.add(midArch);
        sceneElements.push(midArch);
        
        const midText = createVerticalText('吉祥', -4);  // 从6改为-4
        scene.add(midText);
        sceneElements.push(midText);
        
        const decor2 = createDecoration(-10, 'flower');  // 从0改为-10
        scene.add(decor2);
        sceneElements.push(decor2);
        
        // 第四部分：下部
        const pavilion3 = createPavilion(1.1);
        pavilion3.position.set(-2, -12, -3);  // 从-2改为-12
        pavilion3.userData = { baseScale: 1.1 };
        scene.add(pavilion3);
        sceneElements.push(pavilion3);
        
        const decor3 = createDecoration(-14, 'cloud');  // 从-4改为-14
        scene.add(decor3);
        sceneElements.push(decor3);
        
        const bottomArch = createVerticalArch(-18);  // 从-8改为-18
        scene.add(bottomArch);
        sceneElements.push(bottomArch);
        
        // 第五部分：底部
        const bottomText = createVerticalText('如意', -22);  // 从-12改为-22
        scene.add(bottomText);
        sceneElements.push(bottomText);
        
        // 底部扩展部分
        const bottomDecor = createDecoration(-25, 'flower');  // 从-15改为-25
        scene.add(bottomDecor);
        sceneElements.push(bottomDecor);
        
        const bottomArch2 = createVerticalArch(-28);  // 从-18改为-28
        scene.add(bottomArch2);
        sceneElements.push(bottomArch2);
        
        const bottomText2 = createVerticalText('安康', -32);  // 从-22改为-32
        scene.add(bottomText2);
        sceneElements.push(bottomText2);
        
        const pavilion4 = createPavilion(0.8);
        pavilion4.position.set(2.5, -26, -4);  // 从-16改为-26
        pavilion4.userData = { baseScale: 0.8 };
        scene.add(pavilion4);
        sceneElements.push(pavilion4);
        
        const bottomDecor2 = createDecoration(-35, 'cloud');  // 从-25改为-35
        scene.add(bottomDecor2);
        sceneElements.push(bottomDecor2);
        
        const bottomArch3 = createVerticalArch(-38);  // 从-28改为-38
        scene.add(bottomArch3);
        sceneElements.push(bottomArch3);
        
        const bottomText3 = createVerticalText('福满', -42);  // 从-32改为-42
        scene.add(bottomText3);
        sceneElements.push(bottomText3);
        
        // 前景梅花枝装饰（整体下移）
        const plum1 = createPlumDecoration('left', 5);  // 从15改为5
        scene.add(plum1);
        sceneElements.push(plum1);
        
        const plum2 = createPlumDecoration('right', -5);  // 从5改为-5
        scene.add(plum2);
        sceneElements.push(plum2);
        
        const plum3 = createPlumDecoration('left', -15);  // 从-5改为-15
        scene.add(plum3);
        sceneElements.push(plum3);
        
        const plum4 = createPlumDecoration('right', -22);  // 从-12改为-22
        scene.add(plum4);
        sceneElements.push(plum4);
        
        // 底部梅花枝装饰
        const plum5 = createPlumDecoration('left', -30);  // 从-20改为-30
        scene.add(plum5);
        sceneElements.push(plum5);
        
        const plum6 = createPlumDecoration('right', -36);  // 从-26改为-36
        scene.add(plum6);
        sceneElements.push(plum6)
        
        // 地面（扩大范围）
        const ground = createGround();
        scene.add(ground);
        
        // 滚动动画变量
        let isScrolling = false;
        let time = 0;
        
        // 处理滚动 - 更新标题显示和反馈链接
        const handleScroll = () => {
            const scrollPercent = window.scrollY / (document.body.scrollHeight - window.innerHeight);
            const feedbackLink = document.getElementById('feedback');
            
            // 显示对应的标题
            const titles = ['title1', 'title2', 'title3', 'title4'];
            const titlePositions = [0.15, 0.35, 0.55, 0.75];
            
            titles.forEach((id, i) => {
                const title = document.getElementById(id);
                const titlePos = titlePositions[i];
                title.style.opacity = Math.abs(scrollPercent - titlePos) < 0.08 ? '1' : '0';
            });
            
            // 隐藏滚动指示器
            if (scrollPercent > 0.1) {
                document.getElementById('indicator').style.display = 'none';
            }
            
            // 滚动到底部90%时显示反馈链接
            if (scrollPercent > 0.9) {
                feedbackLink.classList.add('visible');
            } else {
                feedbackLink.classList.remove('visible');
            }
        };
        
        // 优化触摸和滚轮滚动 - 使用浏览器原生滚动
        window.addEventListener('wheel', (e) => {
            isScrolling = true;
            clearTimeout(window.scrollTimeout);
            window.scrollTimeout = setTimeout(() => { 
                isScrolling = false; 
            }, 150);
        }, { passive: true });
        
        window.addEventListener('touchstart', (e) => {
            isScrolling = true;
        }, { passive: true });
        
        window.addEventListener('touchend', (e) => {
            setTimeout(() => { 
                isScrolling = false; 
            }, 150);
        }, { passive: true });
        
        window.addEventListener('scroll', handleScroll, { passive: true });
        
        // 自动上下滑动（10秒无交互后）
        let autoScrollTimer = null;
        let inactivityTimer = null;
        let userInteracted = false;
        let autoScrollDirection = 1;
        
        const resetInactivityTimer = () => {
            clearTimeout(inactivityTimer);
            if (!userInteracted) {
                inactivityTimer = setTimeout(() => {
                    startAutoScroll();
                }, 10000);
            }
        };
        
        const startAutoScroll = () => {
            if (autoScrollTimer) return;
            
            autoScrollTimer = setInterval(() => {
                if (!userInteracted && !isScrolling) {
                    const currentScrollY = window.scrollY;
                    const maxScroll = document.body.scrollHeight - window.innerHeight;
                    
                    // 检查是否到达顶部或底部，改变方向（留出更多边距）
                    if (currentScrollY >= maxScroll - 20) {
                        autoScrollDirection = -1;
                    } else if (currentScrollY <= 20) {
                        autoScrollDirection = 1;
                    }
                    
                    // 慢速上下滑动
                    window.scrollBy(0, autoScrollDirection * 0.8);
                }
            }, 40);
        };
        
        const stopAutoScroll = () => {
            clearInterval(autoScrollTimer);
            autoScrollTimer = null;
            clearTimeout(inactivityTimer);
        };
        
        // 检测用户交互
        const detectUserInteraction = () => {
            userInteracted = true;
            stopAutoScroll();
        };
        
        // 监听各种交互事件
        window.addEventListener('touchstart', detectUserInteraction, { passive: true });
        window.addEventListener('touchmove', detectUserInteraction, { passive: true });
        window.addEventListener('touchend', detectUserInteraction, { passive: true });
        window.addEventListener('wheel', detectUserInteraction, { passive: true });
        window.addEventListener('mousedown', detectUserInteraction, { passive: true });
        window.addEventListener('keydown', detectUserInteraction, { passive: true });
        
        // 监听滚动变化，重置无交互计时器
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                if (!userInteracted) {
                    resetInactivityTimer();
                }
            }, 100);
        }, { passive: true });
        
        // 渲染循环
        const animate = () => {
            requestAnimationFrame(animate);
            time += 0.016; // 约60fps
            
            // 直接获取当前滚动位置，立即响应
            const currentScrollY = window.scrollY || window.pageYOffset;
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            const scrollPercent = maxScroll > 0 ? currentScrollY / maxScroll : 0;
            
            // 修复：相机向下移动（与手指滑动方向一致）
            // 整体下移，确保新春显示完整：从顶部8（第一屏）向下移动到底部-45
            camera.position.y = 8 - scrollPercent * 53;
            
            // 增强的相机动画效果
            const breathEffect = Math.sin(time * 0.25) * 0.6;
            const swayEffect = Math.sin(time * 0.15) * 0.4;
            camera.position.x = swayEffect;
            camera.position.z = 25 + breathEffect;
            
            // 相机始终看向场景中心，添加微妙的上下偏移
            const lookOffset = Math.sin(time * 0.1) * 0.3;
            camera.lookAt(swayEffect * 0.5, camera.position.y + lookOffset, 0);
            
            // 场景元素动画 - 更流畅的摆动和呼吸效果
            sceneElements.forEach((element, index) => {
                if (element.rotation) {
                    // 每个元素有不同的摆动频率和幅度
                    const rotationSpeed = 0.3 + (index % 3) * 0.2;
                    const rotationAmount = 0.02 + (index % 5) * 0.01;
                    element.rotation.y = Math.sin(time * rotationSpeed + index) * rotationAmount;
                    element.rotation.x = Math.cos(time * rotationSpeed * 0.7 + index) * rotationAmount * 0.5;
                }
                
                // 前景梅花枝的呼吸效果
                if (element.children && index >= 8) {
                    element.children.forEach((child, childIndex) => {
                        if (child.material && child.material.opacity !== undefined) {
                            const opacityPhase = time * 1.2 + index * 0.3 + childIndex * 0.2;
                            child.material.opacity = 0.5 + Math.sin(opacityPhase) * 0.3;
                        }
                    });
                }
                
                // 亭台楼阁的微妙缩放效果
                if (element.children && index >= 3 && index <= 5) {
                    const scalePhase = time * 0.4 + index * 0.5;
                    const baseScale = element.userData?.baseScale || 1;
                    const scale = baseScale * (1 + Math.sin(scalePhase) * 0.02);
                    element.scale.set(scale, scale, scale);
                }
            });
            
            renderer.render(scene, camera);
        };
        
        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 启动无交互检测（10秒后自动上下滑动）
        resetInactivityTimer();
        
        animate();
    </script>
</body>
</html>