<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>新春纸雕艺术 - 竖版长图</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow-x: hidden;
            overflow-y: auto;
            background: #c8102e;
            font-family: 'KaiTi', 'STKaiti', '楷体', serif;
            height: 100vh;
            position: relative;
        }
        #canvas-container {
            width: 100vw;
            height: 400vh;
            position: relative;
            overflow: hidden;
        }
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            z-index: 1000;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .scroll-indicator {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 14px;
            z-index: 100;
            opacity: 0.7;
            animation: bounce 2s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }
        .section-title {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: #fff8dc;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.7);
            z-index: 50;
            opacity: 0;
            transition: opacity 1s ease;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="loading" id="loading">新春纸雕艺术加载中...</div>
        <div class="scroll-indicator" id="indicator">↓ 向下滑动欣赏 ↓</div>
        <div class="section-title" id="title1" style="top: 15%;">新春</div>
        <div class="section-title" id="title2" style="top: 35%;">纸雕</div>
        <div class="section-title" id="title3" style="top: 55%;">艺术</div>
        <div class="section-title" id="title4" style="top: 75%;">2026</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 竖向滚动长图场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xc8102e);
        
        // 竖版相机设置（更窄的视角，适合长图）
        const camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 25);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // 隐藏加载提示
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('indicator').style.display = 'block';
        }, 1500);
        
        // 灯光设置
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
        mainLight.position.set(0, 20, 15);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 100;
        mainLight.shadow.camera.left = -25;
        mainLight.shadow.camera.right = 25;
        mainLight.shadow.camera.top = 50;
        mainLight.shadow.camera.bottom = -50;
        scene.add(mainLight);
        
        // 纸张材质
        const createPaperMaterial = (color, side = THREE.DoubleSide) => {
            return new THREE.MeshLambertMaterial({
                color: color,
                side: side,
                transparent: true,
                opacity: 0.95
            });
        };
        
        const redPaperMaterial = createPaperMaterial(0xdc143c);
        const whitePaperMaterial = createPaperMaterial(0xfff8dc);
        const lightRedMaterial = createPaperMaterial(0xff6b6b);
        const goldMaterial = createPaperMaterial(0xffd700);
        
        // 创建竖向拱门
        const createVerticalArch = (yPos) => {
            const archGroup = new THREE.Group();
            
            // 竖向门框
            const frameGeometry = new THREE.BoxGeometry(7, 9, 0.3);
            const frame = new THREE.Mesh(frameGeometry, redPaperMaterial);
            frame.castShadow = true;
            frame.receiveShadow = true;
            archGroup.add(frame);
            
            // 拱形门洞
            const archShape = new THREE.Shape();
            archShape.moveTo(-2.5, -2.8);
            archShape.lineTo(-2.5, 2.5);
            archShape.absarc(0, 2.5, 2.5, Math.PI, 0, false);
            archShape.lineTo(2.5, -2.8);
            archShape.lineTo(-2.5, -2.8);
            
            const archHole = new THREE.Path();
            archHole.moveTo(-2, -2.3);
            archHole.lineTo(-2, 2);
            archHole.absarc(0, 2, 2, Math.PI, 0, false);
            archHole.lineTo(2, -2.3);
            archHole.lineTo(-2, -2.3);
            archShape.holes.push(archHole);
            
            const archGeometry = new THREE.ExtrudeGeometry(archShape, {
                depth: 0.3,
                bevelEnabled: true,
                bevelThickness: 0.05,
                bevelSize: 0.05
            });
            const archFrame = new THREE.Mesh(archGeometry, redPaperMaterial);
            archFrame.position.z = 0.15;
            archGroup.add(archFrame);
            
            // 卷草纹装饰
            for (let i = 0; i < 8; i++) {
                const vineGeometry = new THREE.TorusGeometry(0.25 + Math.random() * 0.15, 0.04, 6, 12);
                const vine = new THREE.Mesh(vineGeometry, lightRedMaterial);
                const angle = (i / 8) * Math.PI * 2;
                vine.position.set(
                    Math.cos(angle) * 3.2,
                    Math.sin(angle) * 3.2 + 2.5,
                    0.4
                );
                vine.rotation.z = angle;
                archGroup.add(vine);
            }
            
            archGroup.position.y = yPos;
            return archGroup;
        };
        
        // 创建竖版文字
        const createVerticalText = (text, yPos) => {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 512;
            
            context.fillStyle = '#dc143c';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'bold 160px KaiTi, STKaiti, serif';
            context.fillStyle = '#fff8dc';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // 竖排文字
            const chars = text.split('');
            chars.forEach((char, i) => {
                context.fillText(char, canvas.width / 2, canvas.height * (0.25 + i * 0.25));
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            const textMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            const textGeometry = new THREE.PlaneGeometry(3, 6);
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.y = yPos;
            textMesh.position.z = 0.5;
            
            return textMesh;
        };
        
        // 创建亭台楼阁
        const createPavilion = (scale = 1) => {
            const pavilionGroup = new THREE.Group();
            
            // 基座
            const baseGeometry = new THREE.BoxGeometry(2 * scale, 0.3 * scale, 2 * scale);
            const base = new THREE.Mesh(baseGeometry, whitePaperMaterial);
            base.position.y = 0.15 * scale;
            pavilionGroup.add(base);
            
            // 主体
            const bodyGeometry = new THREE.BoxGeometry(1.5 * scale, 2 * scale, 1.5 * scale);
            const body = new THREE.Mesh(bodyGeometry, whitePaperMaterial);
            body.position.y = 1.3 * scale;
            pavilionGroup.add(body);
            
            // 飞檐
            for (let i = 0; i < 4; i++) {
                const eaveGeometry = new THREE.ConeGeometry(0.8 * scale, 0.5 * scale, 4);
                const eave = new THREE.Mesh(eaveGeometry, whitePaperMaterial);
                const angle = (i / 4) * Math.PI * 2;
                eave.position.set(
                    Math.cos(angle) * 0.5 * scale,
                    2.8 * scale,
                    Math.sin(angle) * 0.5 * scale
                );
                eave.rotation.y = angle;
                eave.castShadow = true;
                pavilionGroup.add(eave);
            }
            
            // 屋顶
            const roofGeometry = new THREE.ConeGeometry(1.2 * scale, 1 * scale, 4);
            const roof = new THREE.Mesh(roofGeometry, redPaperMaterial);
            roof.position.y = 3.5 * scale;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            pavilionGroup.add(roof);
            
            return pavilionGroup;
        };
        
        // 创建装饰图案
        const createDecoration = (yPos, type) => {
            const decorGroup = new THREE.Group();
            
            if (type === 'cloud') {
                // 云纹装饰
                for (let i = 0; i < 6; i++) {
                    const cloudGeometry = new THREE.SphereGeometry(0.6, 8, 6);
                    const cloud = new THREE.Mesh(cloudGeometry, lightRedMaterial);
                    cloud.position.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 3,
                        Math.random() * 3 - 1
                    );
                    cloud.scale.set(1.2, 0.6, 0.9);
                    cloud.material.transparent = true;
                    cloud.material.opacity = 0.6;
                    decorGroup.add(cloud);
                }
            } else if (type === 'flower') {
                // 花纹装饰
                for (let i = 0; i < 8; i++) {
                    const flowerGeometry = new THREE.SphereGeometry(0.3, 6, 4);
                    const flower = new THREE.Mesh(flowerGeometry, goldMaterial);
                    const angle = (i / 8) * Math.PI * 2;
                    flower.position.set(
                        Math.cos(angle) * 2.5,
                        Math.sin(angle) * 0.8,
                        0.5
                    );
                    decorGroup.add(flower);
                }
            }
            
            decorGroup.position.y = yPos;
            return decorGroup;
        };
        
        // 创建地面
        const createGround = () => {
            const groundGeometry = new THREE.PlaneGeometry(50, 200);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xfff8dc,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -15;
            ground.receiveShadow = true;
            return ground;
        };
        
        // 创建梅花枝装饰
        const createPlumDecoration = (side, yPos) => {
            const branchGroup = new THREE.Group();
            
            const mainBranchGeometry = new THREE.CylinderGeometry(0.08, 0.12, 6);
            const mainBranch = new THREE.Mesh(mainBranchGeometry, redPaperMaterial);
            mainBranch.rotation.z = side === 'left' ? 0.4 : -0.4;
            mainBranch.rotation.x = 0.2;
            branchGroup.add(mainBranch);
            
            for (let i = 0; i < 15; i++) {
                const subBranchGeometry = new THREE.CylinderGeometry(0.03, 0.04, 1);
                const subBranch = new THREE.Mesh(subBranchGeometry, redPaperMaterial);
                
                const t = i / 14;
                subBranch.position.set(
                    side === 'left' ? -1.5 + t * 3 : 1.5 - t * 3,
                    -2 + t * 4,
                    0
                );
                subBranch.rotation.z = (Math.random() - 0.5) * 0.8;
                subBranch.rotation.x = (Math.random() - 0.5) * 0.4;
                branchGroup.add(subBranch);
                
                const flowerGeometry = new THREE.SphereGeometry(0.15, 6, 4);
                const flower = new THREE.Mesh(flowerGeometry, lightRedMaterial);
                flower.position.copy(subBranch.position);
                flower.position.y += 0.5;
                flower.position.x += (Math.random() - 0.5) * 0.4;
                flower.material.transparent = true;
                flower.material.opacity = 0.7;
                branchGroup.add(flower);
            }
            
            branchGroup.position.set(side === 'left' ? -8 : 8, yPos, 5);
            return branchGroup;
        };
        
        // 创建长图场景（按垂直位置排列）
        const sceneElements = [];
        
        // 第一部分：顶部（0-10）
        const topArch = createVerticalArch(18);
        scene.add(topArch);
        sceneElements.push(topArch);
        
        const topText = createVerticalText('新春', 22);
        scene.add(topText);
        sceneElements.push(topText);
        
        // 第二部分：上部（8-5）
        const decor1 = createDecoration(12, 'cloud');
        scene.add(decor1);
        sceneElements.push(decor1);
        
        const pavilion1 = createPavilion(1.3);
        pavilion1.position.set(-3, 10, -4);
        scene.add(pavilion1);
        sceneElements.push(pavilion1);
        
        const pavilion2 = createPavilion(0.9);
        pavilion2.position.set(3, 8, -5);
        scene.add(pavilion2);
        sceneElements.push(pavilion2);
        
        // 第三部分：中部（5-0）
        const midArch = createVerticalArch(3);
        scene.add(midArch);
        sceneElements.push(midArch);
        
        const midText = createVerticalText('吉祥', 6);
        scene.add(midText);
        sceneElements.push(midText);
        
        const decor2 = createDecoration(0, 'flower');
        scene.add(decor2);
        sceneElements.push(decor2);
        
        // 第四部分：下部（0到-8）
        const pavilion3 = createPavilion(1.1);
        pavilion3.position.set(-2, -2, -3);
        scene.add(pavilion3);
        sceneElements.push(pavilion3);
        
        const decor3 = createDecoration(-4, 'cloud');
        scene.add(decor3);
        sceneElements.push(decor3);
        
        const bottomArch = createVerticalArch(-8);
        scene.add(bottomArch);
        sceneElements.push(bottomArch);
        
        // 第五部分：底部（-8到-15）
        const bottomText = createVerticalText('如意', -12);
        scene.add(bottomText);
        sceneElements.push(bottomText);
        
        // 前景梅花枝装饰（多层）
        const plum1 = createPlumDecoration('left', 15);
        scene.add(plum1);
        sceneElements.push(plum1);
        
        const plum2 = createPlumDecoration('right', 5);
        scene.add(plum2);
        sceneElements.push(plum2);
        
        const plum3 = createPlumDecoration('left', -5);
        scene.add(plum3);
        sceneElements.push(plum3);
        
        const plum4 = createPlumDecoration('right', -12);
        scene.add(plum4);
        sceneElements.push(plum4);
        
        // 地面
        const ground = createGround();
        scene.add(ground);
        
        // 滚动动画变量
        let scrollY = 0;
        let targetScrollY = 0;
        let isScrolling = false;
        let time = 0;
        
        // 处理滚动
        const handleScroll = () => {
            const scrollPercent = window.scrollY / (document.body.scrollHeight - window.innerHeight);
            targetScrollY = scrollPercent * 35; // 相机移动范围从0到35
            
            // 显示对应的标题
            const titles = ['title1', 'title2', 'title3', 'title4'];
            const titlePositions = [0.15, 0.35, 0.55, 0.75];
            
            titles.forEach((id, i) => {
                const title = document.getElementById(id);
                const titlePos = titlePositions[i];
                
                if (Math.abs(scrollPercent - titlePos) < 0.08) {
                    title.style.opacity = '1';
                } else {
                    title.style.opacity = '0';
                }
            });
            
            // 隐藏滚动指示器
            if (scrollPercent > 0.1) {
                document.getElementById('indicator').style.display = 'none';
            }
        };
        
        // 鼠标滚轮和触摸滚动
        let touchStartY = 0;
        
        window.addEventListener('wheel', (e) => {
            e.preventDefault();
            isScrolling = true;
            setTimeout(() => { isScrolling = false; }, 100);
        }, { passive: false });
        
        window.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
        }, { passive: true });
        
        window.addEventListener('touchmove', (e) => {
            e.preventDefault();
            isScrolling = true;
            setTimeout(() => { isScrolling = false; }, 100);
        }, { passive: false });
        
        window.addEventListener('scroll', handleScroll);
        
        // 自动滚动（如果没有用户交互）
        let autoScrollTimer = null;
        const startAutoScroll = () => {
            autoScrollTimer = setInterval(() => {
                if (!isScrolling) {
                    window.scrollBy(0, 1);
                    if (window.scrollY >= document.body.scrollHeight - window.innerHeight) {
                        window.scrollTo(0, 0);
                    }
                }
            }, 40);
        };
        
        // 用户交互后停止自动滚动
        window.addEventListener('touchstart', () => {
            if (autoScrollTimer) {
                clearInterval(autoScrollTimer);
                autoScrollTimer = null;
            }
        }, { passive: true });
        
        window.addEventListener('wheel', () => {
            if (autoScrollTimer) {
                clearInterval(autoScrollTimer);
                autoScrollTimer = null;
            }
        }, { passive: true });
        
        // 渲染循环
        const animate = () => {
            requestAnimationFrame(animate);
            time += 0.02;
            
            // 平滑滚动
            scrollY += (targetScrollY - scrollY) * 0.12;
            camera.position.y = scrollY;
            
            // 相机轻微摆动
            camera.position.x = Math.sin(time * 0.2) * 0.8;
            camera.lookAt(camera.position.x, scrollY, 0);
            
            // 场景元素动画
            sceneElements.forEach((element, index) => {
                if (element.rotation) {
                    element.rotation.y = Math.sin(time + index) * 0.03;
                }
                
                // 前景元素透明度变化
                if (element.children && (index === 8 || index === 9 || index === 10 || index === 11)) {
                    element.children.forEach(child => {
                        if (child.material && child.material.opacity !== undefined) {
                            child.material.opacity = 0.5 + Math.sin(time * 2 + index) * 0.3;
                        }
                    });
                }
            });
            
            renderer.render(scene, camera);
        };
        
        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 5秒后开始自动滚动
        setTimeout(() => {
            startAutoScroll();
        }, 4000);
        
        animate();
    </script>
</body>
</html>